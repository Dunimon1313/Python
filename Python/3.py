# -*- coding: utf-8 -*-
"""3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G8PDRE-1tmdGJ4r5Ha4_ieo7VdLQGgPX

#Homework 3
1. Upload a personal image in hosting place that can be accesed using an URL.
2. Perform filtering using a 3x3 and then a 5x5 box filter. Show the resulting images. What is the effect of applying a box filter. Explain the differences between the two resulting images.
"""

from skimage import io
import cv2
import numpy as np
import pandas as pd
import cv2 as cv
from google.colab.patches import cv2_imshow # for image display
from skimage import io
from PIL import Image
import matplotlib.pylab as plt

yourUrl = 'https://nmswp.azureedge.net/app/uploads/2020/09/NMS_Origins_1.png'
image = io.imread(yourUrl)

# convert to BGR if you are using openCV
image2 = cv.cvtColor(image, cv.COLOR_BGR2RGB)

#prepare the 3x3 shaped filter
k1 = np.array([[1,1,1],[1,1,1],[1,1,1]])

#prepare the 5x5 shaped filter
k2 = np.array([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]])

# Normalize the kernels if needed. 3x3 filter has 1/9 factor, 5x5 has a 1/25 factor
nk1 = k1/9
nk2 = k2/25
# apply filter
final_frame1 = cv2.filter2D(image2, -1, nk1)
final_frame2 = cv2.filter2D(image2, -1, nk2)

cv2_imshow(final_frame1)
cv2_imshow(final_frame2)

#make sure you are the right data type and values. You can use histogram to check it
# 0-255 if uint8
# 0-1 if float

# visualize
final_frame = final_frame1
plt.hist(final_frame.ravel(),256,[0,256])
plt.show
cv2_imshow(final_frame)

"""3. Obtain and print two-dimensional Gaussian kernels with the following characteristics:<br>
a) $\sigma^2 = 1$, kernel size: 3x3, <br>b) $\sigma^2 = 1.2$, kernel size: 5x5, <br> c) $\sigma^2 = 1.6$, kernel size: 9x9.




"""

#add your code here

# A possible implementation is here. Modify it play with it:
#
import numpy as np

def gkern(l=5, sig=1.):
#    """\
#    creates gaussian kernel with side length l and a sigma of sig
#    """
    ax = np.linspace(-(l - 1) / 2., (l - 1) / 2., l)
    xx, yy = np.meshgrid(ax, ax)
    kernel = np.exp(-0.5 * (np.square(xx) + np.square(yy)) / np.square(sig))
    return kernel / np.sum(kernel)   #note that this normalize the filter to 1. is it desirable?.

"""4. Apply the three
Gaussian kernels obtained previously on your uploaded image. show your filter results. Discuss the differences of
Gaussian operations with different sigmas. Also, compare your results with question 2: what are the differences between these ﬁlters, what do you observe ? Which ﬁltering is the most eﬀective in which images ? Why ?
"""

gf1 = gkern(3, 1)
gf2 = gkern(5, 1.2)
gf3 = gkern(9, 1.6)

gfiltered1 = cv2.filter2D(image2, -1, gf1)
gfiltered2 = cv2.filter2D(image2, -1, gf2)
gfiltered3 = cv2.filter2D(image2, -1, gf3)

cv2_imshow(gfiltered1)
cv2_imshow(gfiltered2)
cv2_imshow(gfiltered3)

"""Although the difference in filtering wasn't much, the gaussian filters showed a better per kernel amount of change. However, these filters are being applied without a goal mentioned in the instructions. I'm not sure which kind of box filter is desired here (blurring, sharpening, etc.) and it is hard to get a good comparison without this direction.

5. Implement the three steps of Sobel filtering. Apply it to the uploaded image for 3 different thresholds. Show the results on
the screen, and discuss the resulting images.
"""

# step 1. Get x and y gradients . Use the correct kernels
xgrad = np.array([[1,2,1],[0,0,0],[-1,-2,-1]])
ygrad = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])
w = cv2.filter2D(image2, -1, xgrad)
e = cv2.filter2D(image2, -1, ygrad)
cv2_imshow(w)
cv2_imshow(e)
# step 2. Compute the magnitude of the gradient
magnitude = np.sqrt(np.square(w) + np.square(e))
magnitude *= 255.0/magnitude.max()
cv2_imshow(magnitude)
# Step 3. Threshold. Choose 3 different threshold. visualize outputs

"""Edit your comments here

6. Use canny edge detector incorporated in opencv. Pick two diferent sets of hysteresys thresholds. What can you tell about the effect on the obtained edges.

The detector captured the details of the foreground of the image very well, with some exceptions. The image I chose is extremely dense at the bottom third, and while quite a few edges were missed, I would say that this detection method did the best out of all the others.
"""

gray = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)

cannyIm = cv2.Canny(gray, threshold1=30, threshold2=100)
cv2_imshow(cannyIm)