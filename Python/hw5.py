# -*- coding: utf-8 -*-
"""HW5

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FHF1RDRkjgPkwMq-C3k5HEUsa7UMcl0E

a) [2%] Find the matrix that represents a rotation of 20 degrees in homogeneous coordinates.
b) [2%] Find the matrix that represents a translation of 2 in X direction, 1 in y direction degrees in homogeneous coordinates.
c) [2%] Plot the points that form the figure in the cartesian plane.
d) [2%] Perform a rotation of 20 degrees on the points and plot them.
e) [2%] Perform a translation in x of 2 and a translation in y of 1 over the points previously rotated. Plot the new obtained points.
f) [2%] Find a transform that represents the operation of rotation of 20 degrees followed by a translation. Compare with the points on e) and verify with a plot the match.
g) [2%] Defines a matrix that represents a translation of 2 in x and a translation of 1 in y, followed by a rotation of 20 degrees. Do the transformation over the initial set of points and compare them.
h) [2%] Are the matrices obtained in g) and f) the same? Why? Justify your answer.
i) [2%] Compute the inverse matrix of the transformation obtained in g). Apply such transformation over the set of points obtained in g). Do the new points match the original points? show plots to verify it.
"""

#import needed libraries
import numpy as np
import matplotlib.pyplot as plt


tetadeg =20

#convert to radians
teta=np.pi*tetadeg /180
tx=2
ty=1

# define your points as homogeneuos coordinates (3 coordinates).
points = np.array([[2,5,1],[4,4,1],[3,2,1],[3,-1,1],[1,-3,1],[-1,-3,1],[-3,-1,1],[-3,2,1],[-4,4,1],[-2,5,1],[-1,4,1],[1,4,1]])
#points.reshape(4, 9)

# Make the points be in columns (you need to transpose them)

points.transpose()

# define your rotation matrix here:
c, s = np.cos(teta), np.sin(teta)

rotationby20= np.array([[c, -s, 0],[s, c, 0],[0,0,1]])


# set up your plot
fig, ax = plt.subplots(1)
ax.clear()
ax.grid(True)
ax.set_aspect('equal')
ax.axhline(0, color='blue')   #draw x axis
ax.axvline(0, color='blue')   #draw y axis

# Plot original points to see everything looks correct
ax.plot(points[0,:],points[1,:],'r*')

# do the roation
rotPoints = np.matmul(points, rotationby20)
plt.plot(rotPoints[0,:],rotPoints[1,:],'bo')
plt.title('Original and rotated')
plt.show()


# define your translation matrix here:
translatexby2yby1= np.array([[1, 0, 2],[0, 1, 1],[0,0,1]])

# translation + rotation
fig, ax = plt.subplots(2)
fig.suptitle('Rotation then translation')
#subplot 1
ax[0].clear()
ax[0].grid(True)
ax[0].axhline(0, color='blue')
ax[0].axvline(0, color='blue')
ax[0].set_aspect('equal')

#subplot 2
ax[1].clear()
ax[1].grid(True)
ax[1].axhline(0, color='blue')
ax[1].axvline(0, color='blue')
ax[1].set_aspect('equal')

# Compute translation over your rotated points
np.matmul(rotPoints, translatexby2yby1)
ax[0].plot(rotPoints[0,:],rotPoints[1,:],'g*')

# compute your rotation and translation matrix
tR = np.matmul(translatexby2yby1, rotationby20)
# Transform your points
tRotPoints3 = np.matmul(points, tR)

#plot points
ax[1].plot(tRotPoints3[0,:],tRotPoints3[1,:],'y+')
plt.show()


# complete a) to g)
points = np.array([[2,5,1],[4,4,1],[3,2,1],[3,-1,1],[1,-3,1],[-1,-3,1],[-3,-1,1],[-3,2,1],[-4,4,1],[-2,5,1],[-1,4,1],[1,4,1]])
#the points in the image are now loaded into points
#a - rotationby20 is our rotating matrix, and it is already homogeneous


#b - translatexby2yby1 is already homogeneous
translatedmatrix = np.matmul(points, translatexby2yby1)
plt.plot(translatedmatrix)
plt.show()

#c
plt.plot(points)
plt.show()

#d
rotatedmatrix = np.matmul(points, rotationby20)
plt.plot(rotatedmatrix)
plt.show()

#e
rotatedmatrix = np.matmul(rotatedmatrix, translatexby2yby1)
plt.plot(rotatedmatrix)
plt.show()

#f
newrotatemat = np.matmul(rotatedmatrix, translatexby2yby1)
plt.plot(newrotatemat)
plt.show()
#g
newtranslate = np.matmul(translatexby2yby1, rotationby20)
plt.plot(newtranslate)
plt.show()
#h    -    Since the translations and rotations in f and g do not change, images f and g should be identical. This is supported by the fact that the operations performed on the original matrix are through multiplication, and matrix multiplication is associative.
#i - the new points match
inverted = np.linalg.inv(newtranslate)
plt.plot(newtranslate)
plt.show()

"""In this point you will be doing forward warping of an image and will be implementing a nearest neighbor interpolation on the following image.

a) [10%] Implement forward warping of the grid points for the homography matrix:
H=[[-2.90978069e+00, 3.54859237e-02, 1.70029144e+03],
[-6.48857919e-01, -8.36844934e-01, 6.24249500e+02],
[-2.10617311e-03, 8.27414761e-06, 1.00000000e+00]]

b) [2%]Visualize the obtained warped image in the range from 0 to 1000 in x and y.
c) [2%]comment about the appereance of the image. Does the image have gaps?
d) [5%] How the warping looks in regions where outside the [0-1000 pixels in x,y]
e) [10%] Implement a forward nearest neighbor interpolation in the warped image
f) [3%]Visualize the interpolated image.
g) [2%] comment about the appereance of the interpolated image versus the initially warped image.
"""

# load an image to warp
# in local machine
import cv2
#img = cv2.imread('C:/Users/gonza/OneDrive/Teaching/CAP4453/homeworksolutions/img2warp.jpg')


# image available at: http://www.cs.ucf.edu/~gvaca/teaching/CAP4453-Fall2021/homeworks/hw5/
from skimage import io
img = io.imread('http://www.cs.ucf.edu/~gvaca/teaching/CAP4453-Fall2021/homeworks/hw5/img2warp.jpg')
cv2.imshow(img)

# the values that can take y
i = np.linspace(0, img.shape[0]-1, img.shape[0]).astype(int)
# the values that can take x
j = np.linspace(0, img.shape[1]-1, img.shape[1]).astype(int)
# combination of values that can take x, and y in a grid
yv, xv = np.meshgrid(i, j)

# nimber of points on the grid
numpoints = xv.ravel().shape[0]

# extract the color channels
r = img[yv.ravel(),xv.ravel(),0]
g = img[yv.ravel(),xv.ravel(),1]
b = img[yv.ravel(),xv.ravel(),2]

# Define Homography matrix
H=np.array([[-2.90978069e+00,  3.54859237e-02,  1.70029144e+03],
 [-6.48857919e-01, -8.36844934e-01,  6.24249500e+02],
 [-2.10617311e-03,  8.27414761e-06,  1.00000000e+00]]
)

# all the values of x coordinates as a row
x_cord = xv.ravel().reshape((1,numpoints))
# all the values of y coordinates as a row
y_cord = yv.ravel().reshape((1,numpoints))

# define the homogeneous coordinates
grid = np.concatenate((x_cord, y_cord, np.ones((1,numpoints))),axis=0)

# transform the grid (your canvas) in the new coordinated determined by the homography defined below
newgrid = np.matmul(,)

# Convert from homogeneous to heterogeneous coordinates
newgridHetero = newgrid[:2,:]   # the x, and y

thethirdcoordinate = newgrid[2,:]
# TO DO : complete the conversion. remember x=X/w
newgridHetero[0,:]=
newgridHetero[1,:]=


# define your new empty canvas (it will have -1 if is not defined)
warped = -np.ones((1001,1001,3)).astype(np.int16)

# Raw approximation. Considering just the integer values
newgrid2= newgridHetero.round().astype(np.int64)

# only consider points that are in your area of interest (0 to 1000)
validsX=np.bitwise_and(newgrid2[0,:]>=0,newgrid2[0,:]<1000)
validsY=np.bitwise_and(newgrid2[1,:]>=0,newgrid2[1,:]<1000)
valids = np.bitwise_and(validsX,validsY)

# assign color to the pixels that are valids
warped[newgrid2[1,valids],newgrid2[0,valids],0]=r[valids]
# TO DO: ASSIGN the remaining colors
#
#


plt.imshow(warped)
plt.show()


# nearest Neighbor interpolation
# your new canvas
warped2 = np.zeros((1001,1001,3)).astype(np.uint8)
# Area where we look for closest valid assignation
area2check=5

# loop over the valid area of the warped image
for i in range(area2check,warped.shape[0]-area2check):
    for j in range(area2check,warped.shape[1]-area2check):
        # check if the pixel has a valid warped value
        if warped[i,j,0]==-1:  #need to look for neighbor
            distance = area2check*area2check+1  # assign a distance larger than any that can be found in the area to check

            # loop over all the possible neighbors
            for k in range(i-area2check,i+area2check):
                for l in range(j-area2check,j+area2check):
                    distancetested = (abs(k-i)+abs(l-j))  # L1 distance
                    if warped[k,l,0]>=0 and distancetested<distance:    # found a warped point , and it is closest
                        distance=distancetested
                        warped2[i,j]=warped[k,l]
        else:  #assign the valid warping
            warped2[i,j] =warped[i,j]


plt.imshow(warped2)
plt.show()

"""Write a function of the form (10%):
imwarped = warpImage(im,H,limit_coordinates)

where im is the input image to be warped, H is the homography, and limit_coordinates defines the limits (xmin,xmax,ymin,ymax) of the warped image.

Write a python function using the expression obtained in the previous point with the following prototype (10%):
"""

H = computeH(im1_pts,im2_pts)

def  warpImage(im,H,limit_coordinates):
  # your function goes here